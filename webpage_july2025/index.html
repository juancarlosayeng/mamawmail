<!DOCTYPE HTML>
<!--
	Template by:
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Reedesign & Addtion:
	Juan Carlos Ayeng, for Mamawmail Project
	July 2025

	NOTE: This site is under construction as well as the entire concepts are being redesigned or refined and elements are added on the fly. Code will be cleaned later, deadlinks deleted, and other coding standards.
-->
<html>
	<head>
		<title>Mamawmail</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="stylesheet" href="assets/css/main2.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		 <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<style>
		canvas {
      border: 1px solid #ccc;
      margin-top: 1em;
      display: block;
      margin-left: 0;
      margin-right: 0;
	  width: 100%;
    }
    button {
      margin-top: 1em;
      padding: 8px 12px;
      font-size: 14px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    button:hover {
      background-color: #2980b9;
    }
    #results {
      text-align: center;
      margin-top: 1em;
      font-weight: bold;
      font-size: 1.1em;
    }
    #results p {
      margin: 0.5em 0;
    }
    #saturation-bar {
      width: 100%;
      height: 20px;
      margin-top: 0.5em;
    }
    #visitorCounter {
	  position: fixed;
	  bottom: 10px;
	  right: 10px;
	  background: #222;
	  color: #fff;
	  font-family: Arial, sans-serif;
	  font-size: 12px;
	  padding: 6px 12px;
	  border-radius: 10px;
	  opacity: 0.85;
	  z-index: 9999;
    }
  </style>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">
											
				<!-- Menu -->
						<div id="navB">
							<ul>
								<li><a href="index.html">Home</a></li>
								<li>
									<a href="#">The Swarm is the AI</a>
																		<ul>
										<li><a href="#">Message Architecture</a></li>
										<li><a href="#"></a>Fractal Propagation Architecture</li>
										<li><a href="#">Crawler Architecture</a>
											<ul>
												<li><a href="#">Regular IP</a></li>
												<li><a href="#">Bluetooth Radio</a></li>
												<li><a href="#">UDP Hole Punch</a></li>
												
											</ul>
										</li>
										<li><a href="#">Intelligence Layer Architecture</a></li>
										<li>
											
										</li>
										<li>
											<a href="#">Self Healing/Pruning Architecture</a>
											<ul>
												<li><a href="#">Self Healing</a></li>
												<li><a href="#">Self Pruning</a></li>
												<li><a href="#"></a></li>
												
											</ul>
										</li>
										<li>
											<a href="#">Singularity Architecture</a>										
											<ul>
												<li><a href="#">Failure Decay</a></li>
												<li><a href="#">Horizontal Singularity</a></li>
												<li><a href="#">Vertical Singularity</a></li>
												
											</ul>
										</li>
										<li><a href="#"></a>Privacy Architecture</li>
										
									</ul>
								</li>
								<li>
									<a href="#">Models</a>

								</li>
								<li><a href="right-sidebar.html"></a>About</li>
								<li><a href="">Help Out</a></li>
							</ul>
						</div>
				<!-- Header -->
					<header id="header">
						
						<div class="logo">
							<span class=""><img src="images/logo4.png" style="width:3.5em; vertical-align: -webkit-baseline-middle; padding-bottom: 1.2rem; " alt="" /></span>
						</div>
						<div class="content">
							<div class="inner">
								<h1><span style="color:aqua;">Mamaw</span>mail</h1>
								<p>
									Serverless. Uncensored Global <b style="color:aqua;">SWARM</b> Communication<br>
									<h5 style="color:aqua;" id="subtitle">AI-Assisted Decentralized Peer-to-Peer Messaging Protocol Using Fractal Propagation with Low Footprint  <br>& <b style="color:white;"> Complete Privacy</b></h5>									
								</p>
							</div>
						</div>
						<nav>
							<ul>
								<li><a href="#Architecture">Architecture</a></li>
								<li><a href="#IFPP">IFPP</a></li>
								<li><a href="#Technology">Technology</a></li>
								<li><a href="#Mathematics">Mathematics</a></li>
								<!--<li><a href="#elements">Elements</a></li>-->
							</ul>
						</nav>

					</header>

				<!-- Main -->
					<div id="main">

						<!-- Architecture -->
							<article id="Architecture">
								<h3 class="major">Architecture</h3>	
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
																<section>
									<h3 class="major">7 Key Architectures</h3>
									<h4>Summary</h4>
									<div class="table-wrapper">
										<table>
											<thead>
												<tr>
													<th>Tech</th>
													<th>Description</th>													
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Message Architecture</td>
													<td>Message in 3 Modular Parts: <br> 
                            <span class="aquacolor">Ephemeral Headers</span> | 
                            <span class="aquacolor">Path/AI Meta</span> | 
                            <span ><b class="aquacolor">Payload</b></span>
                            <br>
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>													
												</tr>
												<tr>
													<td>Propagation Architecture</td>
													<td>Message Packets are sent in a Fractal Pattern. 
                            Federated Learning will determine 
                              <b class="aquacolor">fractal hops</b> versus 
                              <b class="aquacolor">singular hops.</b>
                            <br> 
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>                            
												</tr>
												<tr>
													<td>Crawler Architecture</td>
													<td>IP as Baseline, alternates to Bluetooth Radio or UDP Hole Punching.
                            <br>
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>													
												</tr>
												<tr>
													<td>Intelligence Layer [AI] Architecture</td>
													<td>Intelligence Layer Stores Success/Fail Paths 
                              <b class="aquacolor">WITHOUT the PAYLOAD</b>
                              , Learns and Shares to the swarm.
                            <br>
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>													
												</tr>
												<tr>
													<td>Self-Healing | Self-Pruning Architecture</td>
													<td>Every SUCCESSFUL HANDOFF, Packages are deleted in Transient, Non-Destination Devices, 
                            Freeing Resources and Cleaning up.<br>
                            If successful pathways are not available, new paths will be sought, until a recognized success path is taken.
                            <br>
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>													
												</tr>
                        <tr>
													<td>Singularity Architecture</td>
													<td>
                              <b class="aquacolor">Horizontal Singularity</b><br>
                              The MATHEMATICS for maximizing a successful delivery while minimizing device hops. 
                              A saturation or singularity would be achieved when all paths between devices are mapped.
                              <br><br>
                              <b class="aquacolor">Vertical Singularity</b><br>
                              The MATHEMATICS of minimum Message Packet units for Successful Delivery 
                              until the lowest Latency is achieved. The system is built to always decrease FAILURE DECAY. 
                            <br>
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>													
												</tr>
                        <tr>
													<td>Privacy Architecture</td>
													<td>
                              Encrypted Modular Message Payloads are not needed for path scoring or analysis by AI, 
                              they can be deleted after every Successful HANDOFF. It will always be 
                              <b class="aquacolor">EPHEMERAL</b> while in transit.<br>
                              Message Payloads can only be decrypted by the matching hash of the Destination Device.
                            <br>
                          </td>  
                            <td class="verticalMiddle"><a href="#" class="center button small2">More</a>
                          </td>													
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2">Started June 2025</td>
													
												</tr>
											</tfoot>
										</table>
									</div>

								</section>
                <section>
                    <h3 class="center">Mamawmail MULTICASTING</h3>
                    <p class="center">
                      Multicasting will be developed when the critical mass of 
                      paths have been mapped. Mathematical Models and real-world Testing are needed.
                    </p>
                    <p></p>
                    <p></p>
                </section>    
							</article>

						<!-- Work -->
							<article id="IFPP">
								<h2 class="major">IFPP</h2>
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
                <h3 class="major">Intelligent Fractal Propagation Protocol</h3>
									<h4>Summary</h4>
								<p></p>
                <p></p>
                <a href="#" class="center button small2">More</a>
              </article>

						<!-- About -->
							<article id="Technology">
								<h2 class="major">Technology</h2>
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
                <h3 class="major">The Swarm is the Server</h3>
									<h4>Summary</h4>
								<p></p>
                <p></p>
                <a href="#" class="center button small2">More</a>
              </article>

						<!-- Mathematics -->
							<article id="Mathematics">
								<h2 class="major">Mathematics</h2>
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
								<h3 class="major">Vertical & Horizontal Singularities</h3>
									<br>
									
									
									
<h4>Horizontal Singularity Summary</h4>
<p>
  Horizontal singularity models the <strong>minimum number of unique paths</strong> needed to fully saturate routing knowledge
  across a distributed swarm. In Mamawmail, this means discovering at least one directed route for every device pair
  \((i \rightarrow j)\), with each hop limited to <b>3 outbound unvisited peers</b> per device for up to 4 hops (fractal phase).
</p>

<p>
  This metric is critical for <b class="aquacolor">efficiency and determinism</b>: once routing saturation is achieved,
  further messages need not explore â€” they follow known paths. This defines the moment when swarm behavior shifts
  from <b>probabilistic flooding</b> to <b>deterministic forwarding</b>.
</p>
<br><br><h4>Horizontal Saturation :</h4>
<p style="text-align: center; font-size: 1.2em; color:aqua;">
\[
 \quad \sum_{i=1}^{N} \sum_{\substack{j=1\\ j \ne i}}^{N} \text{ReachablePaths}_{i \rightarrow j} \geq N \cdot (N - 1)
\]
</p>

<p style="text-align: center;">
Where:
<ul style="text-align: left; max-width: 650px; margin: auto; color: #ccc;">
  <li><b>N</b> = Total number of devices</li>
  <li><b>ReachablePaths<sub>iâ†’j</sub></b> = Unique directed paths between each device pair</li>
  <li>Each hop branches to 3 unvisited peers, up to 4 hops max</li>
</ul>
</p>

<p class="center saturation-note">
  Routing saturation is not just a theoretical milestone â€” it reflects a shift to <b>AI-aware routing tables</b> that can score
  and select paths based on energy, latency, or trust. Horizontal singularity lays the mathematical groundwork for building
  <b>adaptive mesh topologies</b> where every node becomes a path-aware router.
</p>

										<br><br>
										<strong>Routing Table Saturation Summary for a 10-Device Mamawmail pre-AI SWARM:</strong><br>
										<progress id="saturation-bar" max="90" value="0"></progress>
										<p id="path-count">Calculating...</p>
										<p id="countdown-message" style="margin-top: 1em; color:aqua"></p>
										
				<canvas id="routingPathCanvas" width="600" height="600"></canvas>
				<p style="text-align: center; color: aqua;">Fractal Saturation Simulation â€“ Routing Path Discovery</p>
				<button onclick="restartFractalSimulation()">Replay Saturation Simulation</button>
										
 

										<table style="margin: 2em auto; border-collapse: collapse; text-align: center;">
										  <caption style="font-weight: bold; font-size: 1.1em; margin-bottom: 0.5em;">Theoretical Horizontal Saturation Points for Swarm Sizes Pre-A.I.  (No Intelligence Layer/Pre Federated-Learning)</caption>
										  <thead>
											<tr style="background-color: #000;">
											  <th style="padding: 0.5em 1em; border: 1px solid #ccc; color:aqua;">Number of Devices (N)</th>
											  <th style="padding: 0.5em 1em; border: 1px solid #ccc; color:aqua;">Total Directed Paths (N Ã— (N - 1))</th>
											</tr>
										  </thead>
										  <tbody>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">10</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">90</td></tr>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">100</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">9,900</td></tr>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">1,000</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">999,000</td></tr>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">10,000</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">99,990,000</td></tr>
										  </tbody>
										</table>

<p style="text-align: center; color: aqua; max-width: 700px; margin: auto;">
  Horizontal Singularity represents <b>convergence</b> â€” the point at which the swarm knows how to reach every other peer
  without rediscovery. Mamawmailâ€™s adaptive routing tables will later compress this data using machine scoring, but 
  the singularity gives the swarm a self-learned map: no servers, no indexes â€” just pure, emergent reachability.
</p>
										<a href="#" class="center button small2">More</a>
										
										
										
										
										
										<br><br> <br><hr><br><br><br>

<!-- Vertical Singularity Summary -->
<h4>Vertical Singularity Summary</h4>
<p>
  Vertical singularity refers to how many <strong>distinct message packets</strong> a single device must send to ensure
  successful delivery to all other devices â€” even if <b>90%</b> of the swarm goes offline.
</p>
<p>
  Unlike the horizontal case (which maps all paths between all pairs), this focuses on 
  <b class="aquacolor">resilience by redundancy</b> for a <b>single sender</b> (Device 0).
  The goal is to ensure every destination has multiple distinct paths that do not share critical middle relays.
</p>
<p style="text-align: center; font-size: 1.2em; color: aqua;">
\[
\text{Vertical Singularity: } \quad M \geq \left\lceil \frac{T - P_{\text{first}}}{P_{\text{linear}}} + 1 \right\rceil
\]
</p>
<p style="text-align: center;">
Where:
<ul style="text-align: left; max-width: 650px; margin: auto; color: #ccc;">
  <li><b>M</b> = Total Messages Sent</li>
  <li><b>T</b> = Number of Target Devices (T = N âˆ’ 1)</li>
  <li><b>P<sub>first</sub></b> = Devices reached in the first 4 fractal hops (up to 81)</li>
  <li><b>P<sub>linear</sub></b> = Average additional devices reached per linear tail (adjusted per swarm size)</li>
</ul>
</p>

<p class="center saturation-note">
  In fractal propagation, each message branches to <b>3</b> devices per hop for the first 4 hops (fractal phase), reaching up to
  <b>3<sup>4</sup> = 81</b> unique devices. After this, propagation continues <b>linearly</b>, one-to-one. To reach the remaining devices,
  additional packets fill in the uncovered paths through slow tail growth.
</p>

<!-- Animations Container -->
<div id="verticalAnimations" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 2em; margin: 2em auto; max-width: 900px;">
  <div style="flex: 1; min-width: 300px;">
    <canvas id="swarmGrowthCanvas" width="400" height="400" style="display:block; margin:auto; border:1px solid #ccc;"></canvas>
    <p style="text-align: center; color: aqua;">Swarm Growth Over Time</p>
    <button onclick="startSwarmGrowth()" style="display:block; margin: 0.5em auto;">Replay Swarm Growth</button>
  </div>
  <div style="flex: 1; min-width: 300px;">
    <canvas id="perHopCanvas" width="400" height="400" style="display:block; margin:auto; border:1px solid #ccc;"></canvas>
    <p style="text-align: center; color: aqua;">Fractal + Linear Propagation</p>
    <button onclick="startPerHopAnimation()" style="display:block; margin: 0.5em auto;">Replay Per-Hop Simulation</button>
  </div>
</div>

<table style="margin: 2em auto; border-collapse: collapse; text-align: center;">
  <caption style="font-weight: bold; font-size: 1.1em; margin-bottom: 0.5em;">
    Estimated Vertical Singularity Packets Needed (Anchored to Fractal + Linear Reach) PRE-A.I. (No Intelligence Layer/Pre Federated-Learning)
  </caption>
  <thead>
    <tr style="background-color: #000;">
      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Swarm Size (N)</th>
      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Target Devices (T = N âˆ’ 1)</th>
      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Reached on 1st Packet (P<sub>first</sub>)</th>
      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Linear Reach/Packet (P<sub>linear</sub>)</th>
      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Estimated Packets (M)</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>10</td><td>9</td><td>9</td><td>â€“</td><td><b class="aquacolor">1</b></td></tr>
    <tr><td>100</td><td>99</td><td>81</td><td>18</td><td><b class="aquacolor">2</b></td></tr>
    <tr><td>1,000</td><td>999</td><td>81</td><td>25</td><td><b class="aquacolor">38</b></td></tr>
    <tr><td>10,000</td><td>9,999</td><td>81</td><td>30</td><td><b class="aquacolor">332</b></td></tr>
    <tr><td>100,000</td><td>99,999</td><td>81</td><td>35</td><td><b class="aquacolor">2,857</b></td></tr>
  </tbody>
</table>
<p class="center saturation-note">
  The value of <b>P<sub>linear</sub></b> increases with network size due to greater opportunity for deeper one-to-one propagation.
  The total packet estimate ensures all nodes are eventually reached through either initial fractal spread or subsequent linear chains.
</p>

<p style="text-align: center; color: aqua; max-width: 700px; margin: auto;">
  Vertical Singularity isn't about reaching the swarm quickly â€” it's about doing so <b>robustly</b>. By adapting to fractal expansion
  and accounting for tail saturation, Mamawmail ensures message survival despite heavy loss. Evaluators should recognize that this
  scaling model is <b>deterministic, decentralized, and congestion-aware</b> â€” key factors in building sovereign, AI-resilient
  communication for tomorrowâ€™s distributed societies.
</p>
<a href="#" class="center button small2">More</a>





					</div>

				<!-- Footer -->
					<footer id="footer">
						<p class="copyright">&copy; Mamawmail June 2025</p>
					</footer>
					

			</div>

		<!-- BG -->
		<video autoplay muted loop id="swarmVideo">
      		<source src="media/1.mp4" type="video/mp4">
    	</video>




<div id="page-wrapper">		
			<!-- Banner -->
				<section id="banner">
					<header>
						<div class="logo">
							<span class=""><img src="images/logo4teal.png" style="width:5.2em; vertical-align: -webkit-baseline-middle; padding-bottom: 0rem; " alt="" /></span>
						</div>
						<h2 class="graycolor"><strong class="logocolor">Communication:</strong> All the Time, Everytime.</h2>
						<p class="graycolor">
							not a <b class="emphasisText">store & forward</b> or a <b class="emphasisText">send & pray</b> system but a real uncensored global swarm communication network
							
						</p>
					</header>
				</section>
		
</div>
<div id="footer">
						<hr />
						<div class="row">
							<div class="col-12">

								<!-- Contact -->
									<section class="contact">
										<header>
											<h3>Ignite the swarm</h3>
										</header>
										<p>Support Mamawmail in making an unencumbered, uncensored, resilient global messaging system.</p>
										<ul class="icons">
											<li><a href="#" class="icon brands fa-twitter"><span class="label">X</span></a></li>
											<li><a href="https://www.facebook.com/61577966164619/" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
											<li><a href="https://github.com/juancarlosayeng/mamawmail" class="icon brands fa-github"><span class="label">Github</span></a></li>
										</ul>
									</section>

								<!-- Copyright -->
									<div class="copyright">
										<ul class=" ">
											<li>&copy; Mamawmail June 2025. All rights reserved.</li>
											<li>Original Template: <a href="http://html5up.net">HTML5 UP</a></li>
											<li>Underwater Video:<a href="https://www.pexels.com/@divesaipan3076/" > [Pexels] JUN HO LEE</a></li>
										</ul>
									</div>

							</div>

						</div>

</div>







		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="assets/js/main2.js"></script>
			<script>
const canvas = document.getElementById("routingPathCanvas");
const ctx = canvas.getContext("2d");
const cx = canvas.width / 2;
const cy = canvas.height / 2;
const N = 10;
const fanOut = 3;
const maxHops = 4;
let nodes = [];
let edges = [];
let nodeColors = [];
const colorPalette = ["#e74c3c", "#3498db", "#f1c40f", "#2ecc71", "#9b59b6", "#1abc9c", "#e67e22", "#34495e", "#7f8c8d", "#ff69b4"];
let pathSet = new Set();

function drawNetwork() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let [from, to] of edges) {
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.strokeStyle = nodeColors[from.id] || "rgba(0, 150, 0, 0.5)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  for (let node of nodes) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, 10, 0, 2 * Math.PI);
    ctx.fillStyle = nodeColors[node.id] || "#27ae60";
    ctx.fill();
    ctx.fillStyle = "white";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.fillText(node.id, node.x, node.y + 3);
  }
}

function simulateFractalSaturation() {
  const countdownEl = document.getElementById("countdown-message");
  countdownEl.innerText = "Calculating routes...";
  nodes = [];
  edges = [];
  pathSet.clear();

  const angleStep = (2 * Math.PI) / N;
  for (let i = 0; i < N; i++) {
    const angle = angleStep * i;
    nodes.push({ id: i, x: cx + 220 * Math.cos(angle), y: cy + 220 * Math.sin(angle) });
    nodeColors[i] = colorPalette[i % colorPalette.length];
  }

  const total = N * (N - 1);
  let currentOrigin = 0;
  let queue = [];
  let visited = new Set();

  function step() {
    if (queue.length === 0) {
      if (currentOrigin >= N) {
        document.getElementById("path-count").innerText = `Unique paths discovered (i â†’ j): ${pathSet.size} / ${total} required`;
        document.getElementById("saturation-bar").value = pathSet.size;
        document.getElementById("saturation-bar").max = total;
        countdownEl.innerText = pathSet.size === total
          ? "âœ… Saturation complete: All paths are known."
          : `ðŸ•’ Waiting for saturation... (${pathSet.size}/${total} paths)`;
        drawNetwork();
        return;
      }
      visited = new Set([currentOrigin]);
      queue = [[currentOrigin, [currentOrigin]]];
      currentOrigin++;
    }

    const [current, path] = queue.shift();
    if (path.length > maxHops + 1) {
      step();
      return;
    }

    const candidates = [];
    for (let i = 0; i < N; i++) {
      if (!visited.has(i)) candidates.push(i);
    }
    for (let i = 0; i < Math.min(fanOut, candidates.length); i++) {
      const next = candidates.splice(Math.floor(Math.random() * candidates.length), 1)[0];
      visited.add(next);
      const newPath = [...path, next];
      edges.push([nodes[current], nodes[next]]);
      pathSet.add(`${path[0]}->${next}`);
      queue.push([next, newPath]);
    }

    document.getElementById("path-count").innerText = `Unique paths discovered (i â†’ j): ${pathSet.size} / ${total} required`;
    document.getElementById("saturation-bar").value = pathSet.size;
    countdownEl.innerText = pathSet.size === total
      ? "âœ… Saturation complete: All paths are known."
      : `ðŸ•’ Waiting for saturation... (${pathSet.size}/${total} paths)`;

    drawNetwork();
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

function restartFractalSimulation() {
  simulateFractalSaturation();
}

// Start on load
//simulateFractalSaturation();
</script>






<!-- Swarm Growth -->
<script>
//let ctx2 = document.getElementById('fractalSaturationCanvas').getContext('2d');


function startSwarmGrowth() {
  const canvas2 = document.getElementById('fractalSaturationCanvas');
  const ctx2 = canvas2.getContext('2d');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let dots = [{ x: 200, y: 200, r: 4 }];
  let growthSteps = 6;
  let step = 0;

  function grow() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let dot of dots) {
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
      ctx.fillStyle = 'aqua';
      ctx.fill();
    }

    if (step < growthSteps) {
      let newDots = [];
      for (let dot of dots) {
        for (let i = 0; i < 3; i++) {
          let angle = Math.random() * Math.PI * 2;
          let dist = 40;
          newDots.push({
            x: dot.x + Math.cos(angle) * dist,
            y: dot.y + Math.sin(angle) * dist,
            r: 3
          });
        }
      }
      dots = newDots;
      step++;
      setTimeout(grow, 600);
    }
  }

  grow();
}
</script>

<!-- Static Per-Hop Animation (already working in canvas) -->
<!-- No changes needed here; your "startPerHopAnimation" already works and is bound. -->
















<script>
function startSwarmGrowth() {
console.log("Simulating Fractal Saturation...");
  const canvas = document.getElementById('swarmGrowthCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let dots = [{ x: 200, y: 200, r: 4 }];
  let growthSteps = 6;
  let step = 0;

  function grow() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let dot of dots) {
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
      ctx.fillStyle = 'aqua';
      ctx.fill();
    }

    if (step < growthSteps) {
      let newDots = [];
      for (let dot of dots) {
        for (let i = 0; i < 3; i++) {
          let angle = Math.random() * Math.PI * 2;
          let dist = 40;
          newDots.push({
            x: dot.x + Math.cos(angle) * dist,
            y: dot.y + Math.sin(angle) * dist,
            r: 3
          });
        }
      }
      dots = newDots;
      step++;
      setTimeout(grow, 600);
    }
  }

  grow();
}

function startPerHopAnimation() {
  const canvas = document.getElementById('perHopCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let nodes = [{ x: 200, y: 200 }];
  let links = [];
  let hop = 0;
  const hops = 10;

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'aqua';
    for (let node of nodes) {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.strokeStyle = '#0ff5';
    for (let link of links) {
      ctx.beginPath();
      ctx.moveTo(link.from.x, link.from.y);
      ctx.lineTo(link.to.x, link.to.y);
      ctx.stroke();
    }
  }

  function expand() {
    if (hop < 4) {
      let newNodes = [];
      for (let node of nodes) {
        for (let i = 0; i < 3; i++) {
          let angle = Math.random() * Math.PI * 2;
          let dist = 40;
          let newNode = {
            x: node.x + Math.cos(angle) * dist,
            y: node.y + Math.sin(angle) * dist
          };
          links.push({ from: node, to: newNode });
          newNodes.push(newNode);
        }
      }
      nodes = newNodes;
    } else if (hop < hops) {
      let newNodes = [];
      for (let node of nodes) {
        let angle = Math.random() * Math.PI * 2;
        let dist = 20;
        let newNode = {
          x: node.x + Math.cos(angle) * dist,
          y: node.y + Math.sin(angle) * dist
        };
        links.push({ from: node, to: newNode });
        newNodes.push(newNode);
      }
      nodes = newNodes;
    }

    draw();
    hop++;
    if (hop < hops) {
      setTimeout(expand, 500);
    }
  }

  expand();
}
</script>


<script>
function onVisible(elementId, callback) {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        callback();
        observer.unobserve(entry.target); // only trigger once
      }
    });
  });
  const el = document.getElementById(elementId);
  if (el) observer.observe(el);
}

onVisible('routingPathCanvas', simulateFractalSaturation);
//onVisible('fractalSaturationCanvas', startSwarmGrowth);
window.onload = () => {startSwarmGrowth();};
onVisible('perHopCanvas', startPerHopAnimation);
</script>







 <div id="visitorCounter">Unique IP visitors: <span id="visitor-count">...</span></div>

<script>
// Set your own unique namespace & key
const namespace = 'mamawmail';
const key = 'webpage_july2025';

fetch(`https://api.countapi.xyz/hit/${namespace}/${key}`)
  .then(res => res.json())
  .then(data => {
    document.getElementById('visitor-count').textContent = data.value;
  });
</script>




	</body>
</html>
