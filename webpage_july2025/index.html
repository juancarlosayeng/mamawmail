<!DOCTYPE HTML>
<!--
	Template by:
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Reedesign & Addtion:
	Juan Carlos Ayeng, for Mamawmail Project
	July 2025

	NOTE: This site is under construction as well as the entire concepts are being redesigned or refined and elements are added on the fly. Code will be cleaned later, deadlinks deleted, and other coding standards.
	UPDATE: August 21, 2025, Dixed layout and spacing. will later separate the scripts and css filess. adding IFPP section now.
-->
<html>
	<head>
		<title>Mamawmail</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="stylesheet" href="assets/css/main2.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		
		<style>
			canvas {
		      border: 1px solid #ccc;
		      margin-top: 1em;
		      display: block;
		      margin-left: 0;
		      margin-right: 0;
			  width: 100%;
		    }
		    button {
		      margin-top: 1em;
		      padding: 8px 12px;
		      font-size: 14px;
		      background-color: #3498db;
		      color: white;
		      border: none;
		      border-radius: 5px;
		      cursor: pointer;
		      display: block;
		      margin-left: auto;
		      margin-right: auto;
		    }
		    button:hover {
		      background-color: #2980b9;
		    }
		    #results {
		      text-align: center;
		      margin-top: 1em;
		      font-weight: bold;
		      font-size: 1.1em;
		    }
		    #results p {
		      margin: 0.5em 0;
		    }
		    #saturation-bar {
		      width: 100%;
		      height: 20px;
		      margin-top: 0.5em;
		    }
		    #visitorCounter {
			  position: fixed;
			  bottom: 10px;
			  right: 10px;
			  background: #222;
			  color: #fff;
			  font-family: Arial, sans-serif;
			  font-size: 12px;
			  padding: 6px 12px;
			  border-radius: 10px;
			  opacity: 0.85;
			  z-index: 9999;
		    }	    
		    .macro-layer, .micro-layer {
		      border: 2px solid #00b4d8;
		      border-radius: 12px;
		      padding: 20px;
		      margin: 20px auto;
		      max-width: 800px;
		      position: relative;
		    }
		    .macro-layer {
		      background: rgba(0, 180, 216, 0.1);
		    }
		    .micro-layer {
		      background: rgba(144, 224, 239, 0.05);
		    }
		    .arrow {
		      text-align: center;
		      font-size: 2em;
		      animation: pulse 1.5s infinite;
		      color: #48cae4;
		    }
		    @keyframes pulse {
		      0%   { transform: translateY(0); opacity: 0.6; }
		      50%  { transform: translateY(10px); opacity: 1; }
		      100% { transform: translateY(0); opacity: 0.6; }
		    }
		    .nodes {
		      display: flex;
		      justify-content: space-around;
		      flex-wrap: wrap;
		      margin-top: 20px;
		    }
		    .node {
		      border: 1px solid #90e0ef;
		      padding: 10px;
		      margin: 10px;
		      border-radius: 10px;
		      width: 140px;
		      background: rgba(255, 255, 255, 0.05);
		      transition: 0.3s;
		    }
		    .node:hover {
		      background: rgba(255, 255, 255, 0.15);
		      cursor: pointer;
		      transform: scale(1.05);
		    }
		    .math {
		      text-align: center;
		      margin-top: 30px;
		      font-size: 1.2em;
		      color: #ffd166;
		    }	
		</style>
</head>
<body class="is-preload">
	<!-- Wrapper -->
	<div id="wrapper">									
		<!-- Menu -->
		<div id="navB">
			<ul>
				<li><a href="index.html">Home</a></li>
				<li>
					<a href="#">The Swarm is the AI</a>
					<ul>
						<li><a href="#">Message Architecture</a></li>
						<li><a href="#">Fractal Propagation Architecture</a></li>
						<li><a href="#">Crawler Architecture</a></li>
					</ul>		
					<ul>
						<li><a href="#">Regular IP</a></li>
						<li><a href="#">Bluetooth Radio</a></li>
						<li><a href="#">UDP Hole Punch</a></li>							
					</ul>
				</li>
				<li>
					<a href="#">Intelligence Layer Architecture</a>
					<ul>
						<li>
							<a href="#">Self Healing/Pruning Architecture</a>
							<ul>
								<li><a href="#">Self Healing</a></li>
								<li><a href="#">Self Pruning</a></li>
								<li><a href="#"></a></li>					
							</ul>
						</li>
						<li>
							<a href="#">Singularity Architecture</a>										
							<ul>
								<li><a href="#">Failure Decay</a></li>
								<li><a href="#">Horizontal Singularity</a></li>
								<li><a href="#">Vertical Singularity</a></li>								
							</ul>
						</li>
						<li>
							<a href="#">Privacy Architecture</a>
						</li>
				</li>					
				<li><a href="#">Models</a></li>
				<li><a href=" ">About</a></li>
				<li><a href="">Help Out</a></li>
			</ul>
		</div>
		<!-- Header -->
		<header id="header">						
			<div class="logo" style="background-color:rgba(255,133,51,0.5);">
				<span class=""><img src="images/logo4.png" style="width:3.5em; vertical-align: -webkit-baseline-middle; padding-bottom: 1.2rem; " alt="" /></span>
			</div>
			<div class="content">
				<div class="inner">
					<h1 style="position: relative; left: 1.1ch; ">
						<span style="color:aqua;">Mamaw</span>
						<span style="color:#fff; position: relative; left: -0.68ch;">m</span>
						<span style="color:#ff6f00; letter-spacing: 0.08em; position: relative; left: -1.5ch;">
							<span style="
								position: relative;
								display: inline-block;
								padding: 0.1em 0.3em;
								border: 1px solid #ff8533;
								border-radius: 999px;
								color: #fff;
								background-color:#ff8533;
								">
								ai
							</span>	
						</span>
						<span style="letter-spacing: 0.1em; position: relative; left: -1.8ch;">l</span>	
					</h1>
					<p>
						Serverless. Uncensored Global <b style="color:aqua;">SWARM</b> Communication
						<br>
						<h5 style="color:aqua;" id="subtitle">Decentralized 
							<span style="color:#fff; background-color:rgba(255,133,51,.8);">AI-Assisted</span> 
							Peer-to-Peer Messaging Protocol Using Fractal Propagation with Low Footprint  
							<br>& 
							<b style="color:white;">Complete Privacy</b>
						</h5>	
					</p>
				</div>
			</div>
			<nav>
				<ul>
					<li><a href="#Architecture">Architecture</a></li>
					<li><a href="#IFPP">IFPP</a></li>
					<li><a href="#Technology">Technology</a></li>
					<li><a href="#Mathematics">Mathematics</a></li>
					<!--<li><a href="#elements">Elements</a></li>-->
				</ul>
			</nav>
		</header>
		<!-- Main -->
		<div id="main">
			<!-- Architecture -->
			<article id="Architecture">
					<h3 class="major">Architecture</h3>	
					<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
				<section>
					<h3 class="major">7 Key Architectures</h3>
					<h4>Summary</h4>
					<div class="table-wrapper">
						<table>
							<thead>
								<tr>
									<th>Tech</th>
									<th>Description</th>													
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Message Architecture</td>
									<td>Message in 3 Modular Parts: <br> 
                            			<span class="aquacolor">Ephemeral Headers</span> | <span class="aquacolor">Path/AI Meta</span> | <span ><b class="aquacolor">Payload</b></span>
                            			<br>
                          			</td>  
                            		<td class="verticalMiddle">
										<a href="#" class="center button small2">More</a>
                          			</td>													
								</tr>
								<tr>
									<td>Propagation Architecture</td>
									<td>
										Message Packets are sent in a Fractal Pattern. Federated Learning will determine <b class="aquacolor">fractal hops</b> versus <b class="aquacolor">singular hops.</b>
                            			<br> 
                          			</td>  
                            		<td class="verticalMiddle">
										<a href="#" class="center button small2">More</a>
                          			</td>                            
								</tr>
								<tr>
									<td>Crawler Architecture</td>
									<td>IP as Baseline, alternates to Bluetooth Radio or UDP Hole Punching.
                            			<br>
                          			</td>  
                            		<td class="verticalMiddle">
										<a href="#" class="center button small2">More</a>
                          			</td>													
								</tr>
								<tr>
									<td>Intelligence Layer [AI] Architecture</td>
									<td>
										Intelligence Layer Stores Success/Fail Paths <b class="aquacolor">WITHOUT the PAYLOAD</b> , Learns and Shares to the swarm.
                            			<br>
                          			</td>  
                            		<td class="verticalMiddle">
										<a href="#" class="center button small2">More</a>
                          			</td>													
								</tr>
								<tr>
									<td>Self-Healing | Self-Pruning Architecture</td>
									<td>Every SUCCESSFUL HANDOFF, Packages are deleted in Transient, Non-Destination Devices, Freeing Resources and Cleaning up.
										<br>
                            			If successful pathways are not available, new paths will be sought, until a recognized success path is taken.
                            			<br>
                          			</td>  
                            		<td class="verticalMiddle">
										<a href="#" class="center button small2">More</a>
                          			</td>													
								</tr>
                        		<tr>
									<td>Singularity Architecture</td>
									<td>
                              			<b class="aquacolor">Horizontal Singularity</b>
										<br>
                              			The MATHEMATICS for maximizing a successful delivery while minimizing device hops. A saturation or singularity would be achieved when all paths between devices are mapped.
                              			<br>
										<br>
                              			<b class="aquacolor">Vertical Singularity</b>
										<br>
	                              		The MATHEMATICS of minimum Message Packet units for Successful Delivery until the lowest Latency is achieved. The system is built to always decrease FAILURE DECAY. 
                            			<br>
                          			</td>  
                            		<td class="verticalMiddle">
										<a href="#" class="center button small2">More</a>
                          			</td>													
								</tr>
                        		<tr>
									td>Privacy Architecture</td>
									<td>
                              			Encrypted Modular Message Payloads are not needed for path scoring or analysis by AI, they can be deleted after every Successful HANDOFF. It will always be 
                              			<b class="aquacolor">EPHEMERAL</b> while in transit.<br>
                              				Message Payloads can only be decrypted by the matching hash of the Destination Device.
                            			<br>
		                    		</td>  
		                        	<td class="verticalMiddle"><a href="#" class="center button small2">More</a>
		                        	</td>													
								</tr>
							</tbody>
							<tfoot>
								<tr>
									<td colspan="2">Started June 2025</td>													
								</tr>
							</tfoot>
						</table>
					</div>
				</section>
                <section>
                    <h3 class="center">Mamawmail MULTICASTING</h3>
                    <p class="center">
                      Multicasting will be developed when the critical mass of 
                      paths have been mapped. Mathematical Models and real-world Testing are needed.
                    </p>
                    <p></p>
                    <p></p>
                </section>    
				</article>
						<!-- IFPP -->
							<article id="IFPP">
								<h2 class="major">IFPP</h2>
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
                				<h3 class="major">Intelligent Fractal Propagation Protocol</h3>
									<h4>Summary</h4>
																	
                						<p></p>
                				<a href="#" class="center button small2">More</a>
              				</article>
						<!-- Technology -->
							<article id="Technology">
								<h2 class="major">Technology</h2>
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
               					<h3 class="major">The Swarm is the Server</h3>
									<h4>Summary</h4>
								<p>
						<!--- Swarm is the AI --->				
								<h1 class="center">The Swarm is the AI </h1>				
								<p class="" style="border:1px solid #00b4d8; border-radius:12px; padding:20px; margin:20px 0; background:#0d1117; color:#ffffff; font-family:'Roboto Mono', monospace;">
							  		Fractal Macro AI + Fractal Micro AI [Multi-Level AI] 
								</p>

								<div class="macro-layer">
								    <h2>🌐 Macro AI Layer (Swarm-Wide)</h2>
								    <ul>
								      <li>Fractal Propagation Strategy</li>
								      <li>Global Message Routing Optimization</li>
								      <li>Collective Learning from Device Histories</li>
								    </ul>
								</div>
  								<div class="arrow">↓</div>
								<div class="micro-layer">
									<h2>📡 Micro AI Layer (Per Device)</h2>
								    <div class="nodes">
								      <div class="node">Node A<br>Trust: ↑<br>Latency: ↓</div>
								      <div class="node">Node B<br>Score: Medium</div>
								      <div class="node">Node C<br>Cache Overflow</div>
								      <div class="node">Node D<br>Been Here ✔️</div>
								      <div class="node">Node E<br>Hop Retry: 1</div>
								    </div>
								    <p style="text-align:center;">Each node learns locally, adapts, and contributes to swarm intelligence</p>
								</div>
								<div class="math">
								    $$ \text{FractalPropagation}(n) = 3^n - \text{VisitedNodes} $$
								    <br>
								    $$ \text{TrustScore}_{device} = \frac{\text{SuccessfulHops}}{\text{TotalAttempts}} $$
								</div>
								<div>
								    Built for MAMAWMAIL | Illustrating Distributed AI with Local Autonomy and Global Emergence
								</div>							
								<br><br><br><hr><br><br><br>							
 								<h2 style="color:#90e0ef;">A. Swarm-Level AI</h2>
								<p>
								    MAMAWMAIL's decentralized network doesn't rely on one central AI. Instead, intelligence emerges from a swarm of devices:
								    <strong>Micro AI</strong> handles routing and trust per device, while <strong>Macro AI</strong> learns across the entire swarm to guide propagation, optimize delivery, and control fractal behavior.<br>
									Monitors System of Devices, their info and knowledge of aggregated pathway lessons. Optimization for message success rate vs network load.
								</p>
								<p>
								    This architecture merges <em>local autonomy</em> and <em>global learning</em> into a self-improving system.
								</p>
								<br> 
								<p>
									Swarm-Level AI can adjust:
									<ul>
										<li>Propagation Radius;</li>
										<li>Max Fractal Hops per device, Start Singular Hops;</li>
										<li>Grouping/Clustering, and other macro-level management;</li>
									</ul>
								</p>
  								<a href=" " style="color:#48cae4; text-decoration:underline;">→ View Full Diagram and Explanation</a>
								<h2 style="color:#90e0ef;">B. Device-Level AI</h2>
								<p>
								    MAMAWMAIL's Device-Level AI Agent on each device [mainly] a lightweight scoring function.<br>
									Learns:
									<ul>
										<li>Best neighbors for routing.</li>
										<li>Local traffic conditions. [Crawler AI]</li>
										<li>Success/failure of past hops.</li>
									</ul>
								  	<br>
									Output:
									<ul>
										<li>Propagation Control: Crawler 'Been Here' Packet Acceptance/Rejection</li>
										<li>Transmit / Handoff Logic</li>
										<li>Retrieval, Incorporation of System Learned Pathways</li>
									</ul>  
								</p>	
								<div id="ai-comparison" style="margin:40px 0; font-family:'Roboto Mono', monospace; color:#ffffff;">
									  <h2 style="color:#90e0ef;">AI Architecture Comparison: Gemini vs. MAMAWMAIL</h2>
									
									  <p style="max-width: 800px; line-height: 1.6;">
									    While Google Gemini AI powers centralized, cloud-based intelligence for search tasks, MAMAWMAIL operates on a radically different model — a decentralized swarm where intelligence is distributed. Here's a side-by-side breakdown of how each system handles core AI components:
									  </p>
									  <!-- Table Wrapper -->
									  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1px; background-color: #48cae4; margin: 30px 0; text-align: left;">
									    <!-- Header Row -->
									    <div style="background-color: #023e8a; padding: 12px; font-weight: bold; color: #ffffff;">Component</div>
									    <div style="background-color: #023e8a; padding: 12px; font-weight: bold; color: #ffffff;">Google Gemini AI</div>
									    <div style="background-color: #023e8a; padding: 12px; font-weight: bold; color: #ffffff;">MAMAWMAIL AI Layer</div>
									
									    <!-- Row 1 -->
									    <div style="background-color: #03045e; padding: 12px;">Query Parsing</div>
									    <div style="background-color: #001d3d; padding: 12px;">LLM on server</div>
									    <div style="background-color: #001d3d; padding: 12px;">Micro AI classifies message priority</div>
									
									    <!-- Row 2 -->
									    <div style="background-color: #03045e; padding: 12px;">Context Awareness</div>
									    <div style="background-color: #001d3d; padding: 12px;">Gemini contextualizes search</div>
									    <div style="background-color: #001d3d; padding: 12px;">Micro AI analyzes device context</div>
									
									    <!-- Row 3 -->
									    <div style="background-color: #03045e; padding: 12px;">Synthesis</div>
									    <div style="background-color: #001d3d; padding: 12px;">Gemini composes direct answer</div>
									    <div style="background-color: #001d3d; padding: 12px;">Macro AI guides swarm routing</div>
									
									    <!-- Row 4 -->
									    <div style="background-color: #03045e; padding: 12px;">Learning Loop</div>
									    <div style="background-color: #001d3d; padding: 12px;">Feedback from user queries</div>
									    <div style="background-color: #001d3d; padding: 12px;">Feedback from packet delivery stats</div>
									  </div>
									
									  <p style="max-width: 800px; line-height: 1.6;">
									    In essence, Gemini operates as a cloud monolith with powerful but centralized intelligence. MAMAWMAIL flips the model: by embedding local learning into each node and coordinating behavior swarm-wide, it creates emergent intelligence without centralized servers. This shift from cloud AI to edge-swarmed AI marks a foundational innovation in decentralized messaging and infrastructure resilience.
									  </p>
								</div>
							
								</p>
				                <p></p>
				                <a href="#" class="center button small2">More</a>
              				</article>				

						<!-- Mathematics -->
							<article id="Mathematics">
								<h2 class="major">Mathematics</h2>
								<span class="image main"><img src="images/underconstruction.png" alt="" /></span>
								<h3 class="major">Vertical & Horizontal Singularities</h3>
								<br>
								<h4>Horizontal Singularity Summary</h4>
								<p>
								  Horizontal singularity models the <strong>minimum number of unique paths</strong> needed to fully saturate routing knowledge
								  across a distributed swarm. In Mamawmail, this means discovering at least one directed route for every device pair
								  \((i \rightarrow j)\), with each hop limited to <b>3 outbound unvisited peers</b> per device for up to 4 hops (fractal phase).
								</p>
								<p>
								  This metric is critical for <b class="aquacolor">efficiency and determinism</b>: once routing saturation is achieved,
								  further messages need not explore — they follow known paths. This defines the moment when swarm behavior shifts
								  from <b>probabilistic flooding</b> to <b>deterministic forwarding</b>.
								</p>
								<br><br>
								<h4>Horizontal Saturation :</h4>
								<p style="text-align: center; font-size: 1.2em; color:aqua;">
								\[
								 \quad \sum_{i=1}^{N} \sum_{\substack{j=1\\ j \ne i}}^{N} \text{ReachablePaths}_{i \rightarrow j} \geq N \cdot (N - 1)
								\]
								</p>
								<p style="text-align: center;">
								Where:
								<ul style="text-align: left; max-width: 650px; margin: auto; color: #ccc;">
								  <li><b>N</b> = Total number of devices</li>
								  <li><b>ReachablePaths<sub>i→j</sub></b> = Unique directed paths between each device pair</li>
								  <li>Each hop branches to 3 unvisited peers, up to 4 hops max</li>
								</ul>
								</p>
								<p class="center saturation-note">
								  Routing saturation is not just a theoretical milestone — it reflects a shift to <b>AI-aware routing tables</b> that can score
								  and select paths based on energy, latency, or trust. Horizontal singularity lays the mathematical groundwork for building
								  <b>adaptive mesh topologies</b> where every node becomes a path-aware router.
								</p>
								<br><br>
								<strong>Routing Table Saturation Summary for a 10-Device Mamawmail pre-AI SWARM:</strong><br>
								<progress id="saturation-bar" max="90" value="0"></progress>
								<p id="path-count">Calculating...</p>
								<p id="countdown-message" style="margin-top: 1em; color:aqua"></p>
										
								<canvas id="routingPathCanvas" width="600" height="600"></canvas>
								<p style="text-align: center; color: aqua;">Fractal Saturation Simulation – Routing Path Discovery</p>
								<button onclick="restartFractalSimulation()">Replay Saturation Simulation</button>
								<table style="margin: 2em auto; border-collapse: collapse; text-align: center;">
										  <caption style="font-weight: bold; font-size: 1.1em; margin-bottom: 0.5em;">Theoretical Horizontal Saturation Points for Swarm Sizes Pre-A.I.  (No Intelligence Layer/Pre Federated-Learning)</caption>
										  <thead>
											<tr style="background-color: #000;">
											  <th style="padding: 0.5em 1em; border: 1px solid #ccc; color:aqua;">Number of Devices (N)</th>
											  <th style="padding: 0.5em 1em; border: 1px solid #ccc; color:aqua;">Total Directed Paths (N × (N - 1))</th>
											</tr>
										  </thead>
										  <tbody>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">10</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">90</td></tr>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">100</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">9,900</td></tr>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">1,000</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">999,000</td></tr>
											<tr><td style="padding: 0.5em 1em; border: 1px solid #ccc;">10,000</td><td style="padding: 0.5em 1em; border: 1px solid #ccc;">99,990,000</td></tr>
										  </tbody>
								</table>
								<p style="text-align: center; color: aqua; max-width: 700px; margin: auto;">
								  Horizontal Singularity represents <b>convergence</b> — the point at which the swarm knows how to reach every other peer
								  without rediscovery. Mamawmail’s adaptive routing tables will later compress this data using machine scoring, but 
								  the singularity gives the swarm a self-learned map: no servers, no indexes — just pure, emergent reachability.
								</p>
								<a href="#" class="center button small2">More</a>
								<br><br> <br><hr><br><br><br>

								<!-- Vertical Singularity Summary -->
								<h4>Vertical Singularity Summary</h4>
								<p>
								  Vertical singularity refers to how many <strong>distinct message packets</strong> a single device must send to ensure
								  successful delivery to all other devices — even if <b>90%</b> of the swarm goes offline.
								</p>
								<p>
								  Unlike the horizontal case (which maps all paths between all pairs), this focuses on 
								  <b class="aquacolor">resilience by redundancy</b> for a <b>single sender</b> (Device 0).
								  The goal is to ensure every destination has multiple distinct paths that do not share critical middle relays.
								</p>
								<p style="text-align: center; font-size: 1.2em; color: aqua;">
									\[
									\text{Vertical Singularity: } \quad M \geq \left\lceil \frac{T - P_{\text{first}}}{P_{\text{linear}}} + 1 \right\rceil
									\]
								</p>
								<p style="text-align: center;">
									Where:
									<ul style="text-align: left; max-width: 650px; margin: auto; color: #ccc;">
									  <li><b>M</b> = Total Messages Sent</li>
									  <li><b>T</b> = Number of Target Devices (T = N − 1)</li>
									  <li><b>P<sub>first</sub></b> = Devices reached in the first 4 fractal hops (up to 81)</li>
									  <li><b>P<sub>linear</sub></b> = Average additional devices reached per linear tail (adjusted per swarm size)</li>
									</ul>
								</p>
								<p class="center saturation-note">
								  In fractal propagation, each message branches to <b>3</b> devices per hop for the first 4 hops (fractal phase), reaching up to
								  <b>3<sup>4</sup> = 81</b> unique devices. After this, propagation continues <b>linearly</b>, one-to-one. To reach the remaining devices,
								  additional packets fill in the uncovered paths through slow tail growth.
								</p>

								<!-- Animations Container -->
								<div id="verticalAnimations" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 2em; margin: 2em auto; max-width: 900px;">
								  <div style="flex: 1; min-width: 300px;">
								    <canvas id="swarmGrowthCanvas" width="400" height="400" style="display:block; margin:auto; border:1px solid #ccc;"></canvas>
								    <p style="text-align: center; color: aqua;">Swarm Growth Over Time</p>
								    <button onclick="startSwarmGrowth()" style="display:block; margin: 0.5em auto;">Replay Swarm Growth</button>
								  </div>
								  <div style="flex: 1; min-width: 300px;">
								    <canvas id="perHopCanvas" width="400" height="400" style="display:block; margin:auto; border:1px solid #ccc;"></canvas>
								    <p style="text-align: center; color: aqua;">Fractal + Linear Propagation</p>
								    <button onclick="startPerHopAnimation()" style="display:block; margin: 0.5em auto;">Replay Per-Hop Simulation</button>
								  </div>
								</div>

								<table style="margin: 2em auto; border-collapse: collapse; text-align: center;">
								  <caption style="font-weight: bold; font-size: 1.1em; margin-bottom: 0.5em;">
								    Estimated Vertical Singularity Packets Needed (Anchored to Fractal + Linear Reach) PRE-A.I. (No Intelligence Layer/Pre Federated-Learning)
								  </caption>
								  <thead>
								    <tr style="background-color: #000;">
								      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Swarm Size (N)</th>
								      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Target Devices (T = N − 1)</th>
								      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Reached on 1st Packet (P<sub>first</sub>)</th>
								      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Linear Reach/Packet (P<sub>linear</sub>)</th>
								      <th style="padding: 0.5em 1em; border: 1px solid #ccc; color: aqua;">Estimated Packets (M)</th>
								    </tr>
								  </thead>
								  <tbody>
								    <tr><td>10</td><td>9</td><td>9</td><td>–</td><td><b class="aquacolor">1</b></td></tr>
								    <tr><td>100</td><td>99</td><td>81</td><td>18</td><td><b class="aquacolor">2</b></td></tr>
								    <tr><td>1,000</td><td>999</td><td>81</td><td>25</td><td><b class="aquacolor">38</b></td></tr>
								    <tr><td>10,000</td><td>9,999</td><td>81</td><td>30</td><td><b class="aquacolor">332</b></td></tr>
								    <tr><td>100,000</td><td>99,999</td><td>81</td><td>35</td><td><b class="aquacolor">2,857</b></td></tr>
								  </tbody>
								</table>
								<p class="center saturation-note">
								  The value of <b>P<sub>linear</sub></b> increases with network size due to greater opportunity for deeper one-to-one propagation.
								  The total packet estimate ensures all nodes are eventually reached through either initial fractal spread or subsequent linear chains.
								</p>
								<p style="text-align: center; color: aqua; max-width: 700px; margin: auto;">
								  Vertical Singularity isn't about reaching the swarm quickly — it's about doing so <b>robustly</b>. By adapting to fractal expansion
								  and accounting for tail saturation, Mamawmail ensures message survival despite heavy loss. Evaluators should recognize that this
								  scaling model is <b>deterministic, decentralized, and congestion-aware</b> — key factors in building sovereign, AI-resilient
								  communication for tomorrow’s distributed societies.
								</p>
								<a href="#" class="center button small2">More</a>
						</article>			
					</div>
					
		<!-- Footer -->
		<footer id="footer">
			<p class="copyright">&copy; Mamawmail June 2025</p>
		</footer>
	</div>

	<!-- Video BackGround  -->
	<video autoplay muted loop id="swarmVideo">
    	<source src="media/1.mp4" type="video/mp4">
    </video>

	<!-- FINAL SUMMARY BANNER | PITCH  -->
	<div id="page-wrapper">		
		<!-- Banner -->
		<section id="banner">
			<header>
				<div class="logo">
					<span class=""><img src="images/logo4teal.png" style="width:5.2em; vertical-align: -webkit-baseline-middle; padding-bottom: 0rem; " alt="" /></span>
				</div>
				<h2 class="graycolor"><strong class="logocolor">Communication:</strong> All the Time, Everytime.</h2>
				<p class="graycolor">
					not a <b class="emphasisText">store & forward</b> or a <b class="emphasisText">send & pray</b> system but a real uncensored global swarm communication network
				</p>
			</header>
		</section>			
	</div>

	<!-- FOOTER  -->
	<div id="footer">
		<hr />
		<div class="row">
			<div class="col-12">
				<!-- Contact -->
				<section class="contact">
					<header>
						<h3>Ignite the swarm</h3>
					</header>
					<p>Support Mamawmail in making an unencumbered, uncensored, resilient global messaging system.</p>
					<ul class="icons">
						<li><a href="#" class="icon brands fa-twitter"><span class="label">X</span></a></li>
						<li><a href="https://www.facebook.com/61577966164619/" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
						<li><a href="https://github.com/juancarlosayeng/mamawmail" class="icon brands fa-github"><span class="label">Github</span></a></li>
					</ul>
				</section>
				<!-- Copyright -->
				<div class="copyright">
					<ul class=" ">
						<li>&copy; Mamawmail June 2025. All rights reserved.</li>
						<li>Original Template: <a href="http://html5up.net">HTML5 UP</a></li>
						<li>Underwater Video:<a href="https://www.pexels.com/@divesaipan3076/" > [Pexels] JUN HO LEE</a></li>
					</ul>
				</div>
			</div>
		</div>
	</div>







		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="assets/js/main2.js"></script>
			<script>
const canvas = document.getElementById("routingPathCanvas");
const ctx = canvas.getContext("2d");
const cx = canvas.width / 2;
const cy = canvas.height / 2;
const N = 10;
const fanOut = 3;
const maxHops = 4;
let nodes = [];
let edges = [];
let nodeColors = [];
const colorPalette = ["#e74c3c", "#3498db", "#f1c40f", "#2ecc71", "#9b59b6", "#1abc9c", "#e67e22", "#34495e", "#7f8c8d", "#ff69b4"];
let pathSet = new Set();

function drawNetwork() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let [from, to] of edges) {
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.strokeStyle = nodeColors[from.id] || "rgba(0, 150, 0, 0.5)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  for (let node of nodes) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, 10, 0, 2 * Math.PI);
    ctx.fillStyle = nodeColors[node.id] || "#27ae60";
    ctx.fill();
    ctx.fillStyle = "white";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.fillText(node.id, node.x, node.y + 3);
  }
}

function simulateFractalSaturation() {
  const countdownEl = document.getElementById("countdown-message");
  countdownEl.innerText = "Calculating routes...";
  nodes = [];
  edges = [];
  pathSet.clear();

  const angleStep = (2 * Math.PI) / N;
  for (let i = 0; i < N; i++) {
    const angle = angleStep * i;
    nodes.push({ id: i, x: cx + 220 * Math.cos(angle), y: cy + 220 * Math.sin(angle) });
    nodeColors[i] = colorPalette[i % colorPalette.length];
  }

  const total = N * (N - 1);
  let currentOrigin = 0;
  let queue = [];
  let visited = new Set();

  function step() {
    if (queue.length === 0) {
      if (currentOrigin >= N) {
        document.getElementById("path-count").innerText = `Unique paths discovered (i → j): ${pathSet.size} / ${total} required`;
        document.getElementById("saturation-bar").value = pathSet.size;
        document.getElementById("saturation-bar").max = total;
        countdownEl.innerText = pathSet.size === total
          ? "✅ Saturation complete: All paths are known."
          : `🕒 Waiting for saturation... (${pathSet.size}/${total} paths)`;
        drawNetwork();
        return;
      }
      visited = new Set([currentOrigin]);
      queue = [[currentOrigin, [currentOrigin]]];
      currentOrigin++;
    }

    const [current, path] = queue.shift();
    if (path.length > maxHops + 1) {
      step();
      return;
    }

    const candidates = [];
    for (let i = 0; i < N; i++) {
      if (!visited.has(i)) candidates.push(i);
    }
    for (let i = 0; i < Math.min(fanOut, candidates.length); i++) {
      const next = candidates.splice(Math.floor(Math.random() * candidates.length), 1)[0];
      visited.add(next);
      const newPath = [...path, next];
      edges.push([nodes[current], nodes[next]]);
      pathSet.add(`${path[0]}->${next}`);
      queue.push([next, newPath]);
    }

    document.getElementById("path-count").innerText = `Unique paths discovered (i → j): ${pathSet.size} / ${total} required`;
    document.getElementById("saturation-bar").value = pathSet.size;
    countdownEl.innerText = pathSet.size === total
      ? "✅ Saturation complete: All paths are known."
      : `🕒 Waiting for saturation... (${pathSet.size}/${total} paths)`;

    drawNetwork();
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

function restartFractalSimulation() {
  simulateFractalSaturation();
}

// Start on load
//simulateFractalSaturation();
</script>






<!-- Swarm Growth -->
<script>
//let ctx2 = document.getElementById('fractalSaturationCanvas').getContext('2d');


function startSwarmGrowth() {
  const canvas2 = document.getElementById('fractalSaturationCanvas');
  const ctx2 = canvas2.getContext('2d');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let dots = [{ x: 200, y: 200, r: 4 }];
  let growthSteps = 6;
  let step = 0;

  function grow() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let dot of dots) {
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
      ctx.fillStyle = 'aqua';
      ctx.fill();
    }

    if (step < growthSteps) {
      let newDots = [];
      for (let dot of dots) {
        for (let i = 0; i < 3; i++) {
          let angle = Math.random() * Math.PI * 2;
          let dist = 40;
          newDots.push({
            x: dot.x + Math.cos(angle) * dist,
            y: dot.y + Math.sin(angle) * dist,
            r: 3
          });
        }
      }
      dots = newDots;
      step++;
      setTimeout(grow, 600);
    }
  }

  grow();
}
</script>

<!-- Static Per-Hop Animation (already working in canvas) -->
<!-- No changes needed here; your "startPerHopAnimation" already works and is bound. -->
















<script>
function startSwarmGrowth() {
console.log("Simulating Fractal Saturation...");
  const canvas = document.getElementById('swarmGrowthCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let dots = [{ x: 200, y: 200, r: 4 }];
  let growthSteps = 6;
  let step = 0;

  function grow() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let dot of dots) {
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
      ctx.fillStyle = 'aqua';
      ctx.fill();
    }

    if (step < growthSteps) {
      let newDots = [];
      for (let dot of dots) {
        for (let i = 0; i < 3; i++) {
          let angle = Math.random() * Math.PI * 2;
          let dist = 40;
          newDots.push({
            x: dot.x + Math.cos(angle) * dist,
            y: dot.y + Math.sin(angle) * dist,
            r: 3
          });
        }
      }
      dots = newDots;
      step++;
      setTimeout(grow, 600);
    }
  }

  grow();
}

function startPerHopAnimation() {
  const canvas = document.getElementById('perHopCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let nodes = [{ x: 200, y: 200 }];
  let links = [];
  let hop = 0;
  const hops = 10;

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'aqua';
    for (let node of nodes) {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.strokeStyle = '#0ff5';
    for (let link of links) {
      ctx.beginPath();
      ctx.moveTo(link.from.x, link.from.y);
      ctx.lineTo(link.to.x, link.to.y);
      ctx.stroke();
    }
  }

  function expand() {
    if (hop < 4) {
      let newNodes = [];
      for (let node of nodes) {
        for (let i = 0; i < 3; i++) {
          let angle = Math.random() * Math.PI * 2;
          let dist = 40;
          let newNode = {
            x: node.x + Math.cos(angle) * dist,
            y: node.y + Math.sin(angle) * dist
          };
          links.push({ from: node, to: newNode });
          newNodes.push(newNode);
        }
      }
      nodes = newNodes;
    } else if (hop < hops) {
      let newNodes = [];
      for (let node of nodes) {
        let angle = Math.random() * Math.PI * 2;
        let dist = 20;
        let newNode = {
          x: node.x + Math.cos(angle) * dist,
          y: node.y + Math.sin(angle) * dist
        };
        links.push({ from: node, to: newNode });
        newNodes.push(newNode);
      }
      nodes = newNodes;
    }

    draw();
    hop++;
    if (hop < hops) {
      setTimeout(expand, 500);
    }
  }

  expand();
}
</script>


<script>
function onVisible(elementId, callback) {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        callback();
        observer.unobserve(entry.target); // only trigger once
      }
    });
  });
  const el = document.getElementById(elementId);
  if (el) observer.observe(el);
}

onVisible('routingPathCanvas', simulateFractalSaturation);
//onVisible('fractalSaturationCanvas', startSwarmGrowth);
window.onload = () => {startSwarmGrowth();};
onVisible('perHopCanvas', startPerHopAnimation);
</script>


<!--
 <div id="visitorCounter">Unique IP visitors: <span id="visitor-count">...</span></div>
-->

	
<script>
// Set your own unique namespace & key
const namespace = 'mamawmail';
const key = 'webpage_july2025';

fetch(`https://api.countapi.xyz/hit/${namespace}/${key}`)
  .then(res => res.json())
  .then(data => {
    document.getElementById('visitor-count').textContent = data.value;
  });
</script>






	


	</body>
</html>














